<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>apt: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">apt
   &#160;<span id="projectnumber">2.2.3</span>
   </div>
   <div id="projectbrief">commandline package manager</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Module <a class="el" href="group__acquire.xhtml">acquire</a>  </dt>
<dd><a class="anchor" id="_todo000016"></a>Acquire supports inserting an object into several queues at once, but it is not clear what its behavior in this case is, and no subclass of pkgAcquire::Item seems to actually use this capability.  </dd>
<dt>Member <a class="el" href="classAPT_1_1CacheSetHelper.xhtml#ae746b3086d53d0a5ad666675cb003ef2">CacheSetHelper::PackageFromString</a>  (<a class="el" href="classAPT_1_1PackageContainerInterface.xhtml">PackageContainerInterface</a> *const pci, <a class="el" href="classpkgCacheFile.xhtml">pkgCacheFile</a> &amp;Cache, std::string const &amp;pattern)</dt>
<dd><a class="anchor" id="_todo000033"></a>hm, hm, regexp/fnmatch incompatible?  </dd>
<dt>Member <a class="el" href="classCommandLine.xhtml#ae95847c73c63fe09a42b29bb0525c14c">CommandLine::GetCommand</a>  (<a class="el" href="structCommandLine_1_1Dispatch.xhtml">Dispatch</a> const *const Map, unsigned int const argc, char const *const *const argv) APT_PURE</dt>
<dd><a class="anchor" id="_todo000035"></a>How like is it that an option parameter will be also a valid Match ?  </dd>
<dt>Member <a class="el" href="classdebReleaseIndex.xhtml#aeaf2e9db914b9ddb21625a6172e5882f">debReleaseIndex::Load</a>  (std::string const &amp;Filename, std::string *const ErrorText) APT_OVERRIDE</dt>
<dd><a class="anchor" id="_todo000043"></a>find better tag name  </dd>
<dt>Member <a class="el" href="classedspListParser.xhtml#a8a5b0770dc74cc79cd453d00021eb83b">edspListParser::ParseStatus</a>  (pkgCache::PkgIterator &amp;Pkg, pkgCache::VerIterator &amp;Ver) APT_OVERRIDE</dt>
<dd><a class="anchor" id="_todo000051"></a>Using an overriding pin is wrong.  </dd>
<dt>Member <a class="el" href="classMMap.xhtml#abf6208ba8fc33da8217ee57b919c1892">MMap::Map</a>  (<a class="el" href="classFileFd.xhtml">FileFd</a> &amp;Fd)</dt>
<dd><a class="anchor" id="_todo000037"></a>Writing to compressed fd's ?  </dd>
<dt>Member <a class="el" href="classAPT_1_1Progress_1_1PackageManagerFancy.xhtml#afdd3a4f5c1ff9a58b5588dd9da3ee4ec">PackageManagerFancy::GetTerminalSize</a>  ()</dt>
<dd><a class="anchor" id="_todo000056"></a>get from "child_pty" instead?  </dd>
<dt>Member <a class="el" href="classAPT_1_1Progress_1_1PackageManagerProgressDeb822Fd.xhtml#a585ae4dbdec6a715a3ea524952da63e8">PackageManagerProgressDeb822Fd::StartDpkg</a>  () APT_OVERRIDE</dt>
<dd><a class="anchor" id="_todo000055"></a>use SetCloseExec here once it taught about throwing  </dd>
<dt>Member <a class="el" href="classAPT_1_1Progress_1_1PackageManagerProgressFd.xhtml#a585ae4dbdec6a715a3ea524952da63e8">PackageManagerProgressFd::StartDpkg</a>  () APT_OVERRIDE</dt>
<dd><a class="anchor" id="_todo000054"></a>use SetCloseExec here once it taught about throwing  </dd>
<dt>Member <a class="el" href="classpkgAcqDiffIndex.xhtml#a3980b570ebaa4972bbe5218ba6d3e32b">pkgAcqDiffIndex::ParseDiffIndex</a>  (std::string const &amp;IndexDiffFile)</dt>
<dd><a class="anchor" id="_todo000003"></a>all of pdiff supports only .gz compressed patches  </dd>
<dt>Member <a class="el" href="classpkgAcqDiffIndex.xhtml#a79496027fb5023578c8726a103bea532">pkgAcqDiffIndex::pkgAcqDiffIndex</a>  (<a class="el" href="classpkgAcquire.xhtml" title="Represents the process by which a pkgAcquire object should retrieve a file or a collection of files.">pkgAcquire</a> *const Owner, <a class="el" href="classpkgAcqMetaClearSig.xhtml" title="An item responsible for downloading clearsigned metaindexes {{{.">pkgAcqMetaClearSig</a> *const TransactionManager, <a class="el" href="classIndexTarget.xhtml" title="Information about an index file.">IndexTarget</a> const &amp;Target) APT_NONNULL(2</dt>
<dd><a class="anchor" id="_todo000002"></a>Magic number as an upper bound on pdiffs we will reasonably acquire  </dd>
<dt>Class <a class="el" href="classpkgAcqIndex.xhtml">pkgAcqIndex</a>  </dt>
<dd><a class="anchor" id="_todo000005"></a>Why does <a class="el" href="classpkgAcqIndex.xhtml" title="An acquire item that is responsible for fetching an index {{{ file (e.g., Packages or Sources).">pkgAcqIndex</a> have protected members?  </dd>
<dt>Member <a class="el" href="classpkgAcqIndexDiffs.xhtml#a6822b4355d68d4683938302c3c4bee8b">pkgAcqIndexDiffs::available_patches</a>  </dt>
<dd><a class="anchor" id="_todo000006"></a>These are indexed by sha1sum; why not use some sort of dictionary instead of relying on ordering and stripping them off the front?  </dd>
<dt>Class <a class="el" href="classpkgAcqMetaSig.xhtml">pkgAcqMetaSig</a>  </dt>
<dd><a class="anchor" id="_todo000004"></a>Why protected members? </dd>
<dt>Member <a class="el" href="classpkgAcqMetaSig.xhtml#a3f0cc0b4b3be0867c4412bf15c3f7043">pkgAcqMetaSig::Failed</a>  (std::string const &amp;Message, <a class="el" href="classpkgAcquire.xhtml#a29c0cb60fa0c1e5f67d911bed92f2006" title="Set up the default method parameters.">pkgAcquire::MethodConfig</a> const *const Cnf) APT_OVERRIDE</dt>
<dd><a class="anchor" id="_todo000001"></a>this is used often (e.g. in pkgAcqIndexTrans) so refactor  </dd>
<dt>Class <a class="el" href="classpkgAcquire.xhtml">pkgAcquire</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000009"></a>Like everything else in the Acquire system, this has way too many protected items.</p>
<p class="interdd"><a class="anchor" id="_todo000018"></a>Why so many protected values? </p>
<p class="enddd"><a class="anchor" id="_todo000017"></a>Why all the protected data items and methods?  </p>
</dd>
<dt>Member <a class="el" href="classpkgAcquire.xhtml#a006a979c4801f6b6ceb33cb3acd6dc89">pkgAcquire::Access</a>  </dt>
<dd><a class="anchor" id="_todo000011"></a>Doesn't this duplicate Config-&gt;Access?  </dd>
<dt>Member <a class="el" href="classpkgAcquire.xhtml#abf4fe627ab803887ecd2a8af30f17147">pkgAcquire::Bump</a>  ()</dt>
<dd><a class="anchor" id="_todo000027"></a>Why both this and <a class="el" href="classpkgAcquire.xhtml#a5b2dd956b1adc90b13d47e26121d5486" title="Send idle items to the worker process.">Cycle()</a>? Are they expected to be different someday?  </dd>
<dt>Member <a class="el" href="classpkgAcquire.xhtml#ab04e9ee398f825f50e4f1ea7eaf37f77">pkgAcquire::Configs</a>  </dt>
<dd><a class="anchor" id="_todo000022"></a>why a hand-managed config dictionary instead of std::map?  </dd>
<dt>Member <a class="el" href="classpkgAcquire.xhtml#a849bc65c54e1bcbe8a7f053ce2cec672">pkgAcquire::InReady</a>  </dt>
<dd><a class="anchor" id="_todo000012"></a>Is this right? It's a guess.  </dd>
<dt>Member <a class="el" href="classpkgAcquire.xhtml#a2f4e8b582eeece0747d3fee5858b1a27">pkgAcquire::Items</a>  </dt>
<dd><a class="anchor" id="_todo000023"></a>why a by-hand list instead of an STL structure?  </dd>
<dt>Member <a class="el" href="classpkgAcquire.xhtml#a76f3403ec41517cce48d96a5b1f54e1e">pkgAcquire::ItemStart</a>  (<a class="el" href="structpkgAcquire_1_1QItem.xhtml" title="A single item placed in this queue.">QItem</a> *Itm, unsigned long long Size)</dt>
<dd><a class="anchor" id="_todo000026"></a>Unimplemented. Implement it or remove?  </dd>
<dt>Member <a class="el" href="classpkgAcquire.xhtml#add1daf6c866236479bdac390ed41f80a">pkgAcquire::Next</a>  </dt>
<dd><a class="anchor" id="_todo000028"></a>Why not an STL container?  </dd>
<dt>Member <a class="el" href="classpkgAcquire.xhtml#a70b012fdfb38bfe94b52924d45c5462d">pkgAcquire::NextQueue</a>  </dt>
<dd><a class="anchor" id="_todo000010"></a>This is always NULL; is it just for future use?  </dd>
<dt>Member <a class="el" href="classpkgAcquire.xhtml#a27ee7762ef1caaf3ec8c3598c15e7886">pkgAcquire::OutQueue</a>  </dt>
<dd><a class="anchor" id="_todo000014"></a>Wouldn't a std::dequeue be more appropriate?  </dd>
<dt>Member <a class="el" href="classpkgAcquire.xhtml#a0b8717fb6d062212c251900cee4e6004">pkgAcquire::OutReady</a>  </dt>
<dd><a class="anchor" id="_todo000013"></a>Is this right?  </dd>
<dt>Member <a class="el" href="classpkgAcquire.xhtml#a9e42b66f176afafc1c75e78289e80e76">pkgAcquire::Queues</a>  </dt>
<dd><a class="anchor" id="_todo000020"></a>why a hand-managed list of queues instead of std::list or std::set?  </dd>
<dt>Member <a class="el" href="classpkgAcquire.xhtml#a26a68d57a249a042c1e32186ce2fce8b">pkgAcquire::RunMessages</a>  ()</dt>
<dd><a class="anchor" id="_todo000015"></a>Several message types lack separate handlers. </dd>
<dt>Member <a class="el" href="classpkgAcquire.xhtml#ae49de4816f8591cf1ccb70329d4dcb8c">pkgAcquire::Workers</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000025"></a>Why not just use a std::set? </p>
<p class="interdd"><a class="anchor" id="_todo000024"></a>This is plural because support exists in Queue for multiple workers. However, it does not appear that there is any way to actually associate more than one worker with a queue.</p>
<p class="enddd"><a class="anchor" id="_todo000021"></a>why a hand-managed list of workers instead of std::list or std::set?  </p>
</dd>
<dt>Class <a class="el" href="classpkgAcquireStatus.xhtml">pkgAcquireStatus</a>  </dt>
<dd><a class="anchor" id="_todo000019"></a>Why protected members?  </dd>
<dt>Member <a class="el" href="classpkgAcquireStatus.xhtml#a61c6f568f6582836223430d117a62e69">pkgAcquireStatus::MediaChange</a>  (std::string Media, std::string Drive)=0</dt>
<dd><a class="anchor" id="_todo000029"></a>This is a horrible blocking monster; it should be CPSed with prejudice.  </dd>
<dt>Member <a class="el" href="structpkgCache_1_1DescFile.xhtml#a924e1d37050236e62bcb18be0c5e5f0f">pkgCache&lt; Str, Itr &gt;::DescFile::Size</a>  </dt>
<dd><a class="anchor" id="_todo000063"></a>document <a class="el" href="structpkgCache_1_1DescFile.xhtml#a924e1d37050236e62bcb18be0c5e5f0f">pkgCache::DescFile::Size</a>  </dd>
<dt>Member <a class="el" href="structpkgCache_1_1Description.xhtml#ad7272a2d6b3ef69ce73a4bb6b3378e92">pkgCache&lt; Str, Itr &gt;::Description::FileList</a>  </dt>
<dd><a class="anchor" id="_todo000064"></a>document <a class="el" href="structpkgCache_1_1Description.xhtml#ad7272a2d6b3ef69ce73a4bb6b3378e92">pkgCache::Description::FileList</a>  </dd>
<dt>Member <a class="el" href="structpkgCache_1_1PackageFile.xhtml#a87b9212b05c48e953f3d476eee0a3595">pkgCache&lt; Str, Itr &gt;::PackageFile::Flags</a>  </dt>
<dd><a class="anchor" id="_todo000061"></a>document <a class="el" href="structpkgCache_1_1PackageFile.xhtml#a87b9212b05c48e953f3d476eee0a3595">PackageFile::Flags</a>  </dd>
<dt>Member <a class="el" href="structpkgCache_1_1PackageFile.xhtml#a89f262193bef3d4f8e249f835a9195dc">pkgCache&lt; Str, Itr &gt;::PackageFile::IndexType</a>  </dt>
<dd><a class="anchor" id="_todo000060"></a>enumerate at least the possible indexes  </dd>
<dt>Member <a class="el" href="structpkgCache_1_1ReleaseFile.xhtml#a87b9212b05c48e953f3d476eee0a3595">pkgCache&lt; Str, Itr &gt;::ReleaseFile::Flags</a>  </dt>
<dd><a class="anchor" id="_todo000059"></a>document <a class="el" href="structpkgCache_1_1PackageFile.xhtml#a87b9212b05c48e953f3d476eee0a3595">PackageFile::Flags</a>  </dd>
<dt>Member <a class="el" href="structpkgCache_1_1VerFile.xhtml#a924e1d37050236e62bcb18be0c5e5f0f">pkgCache&lt; Str, Itr &gt;::VerFile::Size</a>  </dt>
<dd><a class="anchor" id="_todo000062"></a>document <a class="el" href="structpkgCache_1_1VerFile.xhtml#a924e1d37050236e62bcb18be0c5e5f0f">pkgCache::VerFile::Size</a>  </dd>
<dt>Member <a class="el" href="classpkgCacheGenerator.xhtml#a69c67e48848ceba8d57db704c03875e8">pkgCacheGenerator::MakeStatusCache</a>  (<a class="el" href="classpkgSourceList.xhtml">pkgSourceList</a> &amp;List, <a class="el" href="classOpProgress.xhtml">OpProgress</a> *Progress, <a class="el" href="classMMap.xhtml">MMap</a> **OutMap, <a class="el" href="classpkgCache.xhtml">pkgCache</a> **OutCache, bool AllowMem=false)</dt>
<dd><a class="anchor" id="_todo000065"></a>deprecate the ignored AllowMem parameter  </dd>
<dt>Member <a class="el" href="classpkgCdrom.xhtml#a6d1bdb3f763da1f0a388888f206a50a6">pkgCdrom::Add</a>  (<a class="el" href="classpkgCdromStatus.xhtml">pkgCdromStatus</a> *log)</dt>
<dd><a class="anchor" id="_todo000034"></a>We ignore stat() errors here as we usually have only one of those in use  </dd>
<dt>Member <a class="el" href="classpkgDepCache.xhtml#a1ab9378572dc74fc8088fd690d494570">pkgDepCache::GetRootSetFunc</a>  ()</dt>
<dd><a class="anchor" id="_todo000050"></a>Is this the best place for this function? Perhaps the settings for mark-and-sweep should be stored in a single external class?  </dd>
<dt>Member <a class="el" href="classpkgDepCache_1_1Policy.xhtml#a6ab9cf0a0e662622e47d3fe99cafc817">pkgDepCache::Policy::IsImportantDep</a>  (DepIterator const &amp;Dep) const</dt>
<dd><a class="anchor" id="_todo000049"></a>this is a meant as a temporary solution until the  </dd>
<dt>Member <a class="el" href="classpkgDPkgPM.xhtml#a807efc750fd999dcd0e3a1c90f5684ca">pkgDPkgPM::Go</a>  (<a class="el" href="classAPT_1_1Progress_1_1PackageManager.xhtml">APT::Progress::PackageManager</a> *progress) APT_OVERRIDE</dt>
<dd><a class="anchor" id="_todo000047"></a>workaround for dpkg bug, see our ./test-bug-740843-versioned-up-down-breaks test  </dd>
<dt>Member <a class="el" href="classpkgDPkgPM.xhtml#a367828235aced7bf124b0cd6827d9a2d">pkgDPkgPM::OpenLog</a>  ()</dt>
<dd><a class="anchor" id="_todo000046"></a>use a better string after freeze  </dd>
<dt>Member <a class="el" href="classpkgDPkgPM.xhtml#a6be54fa1743a469c0119ed27ee6e1087">pkgDPkgPM::ProcessDpkgStatusLine</a>  (char *line)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000044"></a>this needs a muliarch testcase </p>
<p class="enddd"><a class="anchor" id="_todo000045"></a>2: is "pkgname" here reliable with dpkg only sending us  </p>
</dd>
<dt>Member <a class="el" href="classpkgPackageManager.xhtml#aeca45edd4cb610fe7e7c1d39ed110b03">pkgPackageManager::EarlyRemove</a>  (PkgIterator Pkg, DepIterator const *const Dep) APT_MUSTCHECK</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000058"></a>Message should talk about Protected, not Essential, and unified. </p>
<p class="enddd"><a class="anchor" id="_todo000057"></a>Unify messaging with Protected below.  </p>
</dd>
<dt>Member <a class="el" href="classpkgPolicy.xhtml#a09125a1b5560d8c43c8e669560663a7d">pkgPolicy::pkgPolicy</a>  (<a class="el" href="classpkgCache.xhtml">pkgCache</a> *Owner)</dt>
<dd><a class="anchor" id="_todo000067"></a>make ExpressionMatches static to use it here easily  </dd>
<dt>Member <a class="el" href="classpkgProblemResolver.xhtml#a4e1bfb762b1ddbf737d74663852aeafa">pkgProblemResolver::ResolveInternal</a>  (bool const BrokenFix=false)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000031"></a>use DoUpgrade(Pkg) instead? </p>
<p class="enddd"><a class="anchor" id="_todo000030"></a>we should undo the complete MarkInstall process here  </p>
</dd>
<dt>Member <a class="el" href="classpkgSrcRecords_1_1Parser.xhtml#a3197f435b17e87aaab7fe2e798444c03">pkgSrcRecords::Parser::BuildDepends</a>  (std::vector&lt; BuildDepRec &gt; &amp;BuildDeps, bool const &amp;ArchOnly, bool const &amp;StripMultiArch=true)=0</dt>
<dd><a class="anchor" id="_todo000068"></a>Add a parameter to specify which architecture to use for [wildcard] matching  </dd>
<dt>Member <a class="el" href="classpkgSystem.xhtml#a907b351d54f285f936dd6d2dae4de2ca">pkgSystem::MultiArchSupported</a>  () const =0</dt>
<dd><a class="anchor" id="_todo000066"></a>these methods should be virtual  </dd>
<dt>Member <a class="el" href="classSigVerify.xhtml#a490c2d5199afc84532e9d4a41f2de667">SigVerify::CopyAndVerify</a>  (std::string CDROM, std::string Name, std::vector&lt; std::string &gt; &amp;SigList, std::vector&lt; std::string &gt; PkgList, std::vector&lt; std::string &gt; SrcList)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000053"></a>delete any existing gpg file? </p>
<p class="enddd"><a class="anchor" id="_todo000052"></a>delete any existing gpg file?  </p>
</dd>
<dt>Member <a class="el" href="classAPT_1_1StateChanges.xhtml#a6f5fc89488e7b1c1b0d68a586e23d7c1">StateChanges::Save</a>  (bool const DiscardOutput=false)</dt>
<dd><a class="anchor" id="_todo000069"></a>supported only since 1.17.7 in dpkg </dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
